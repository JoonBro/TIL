### 일급 컬렉션

```java
public class GameRanking {

    private Map<String, String> ranks;

    public GameRanking(Map<String, String> ranks) {
        this.ranks = ranks;
    }
}
```



* 컬렉션을 wrapping하면서 그 외 다른 멤버변수가 없는 상태
  * 비즈니스에 종속적인 자료구조
  * 불변성이 필요하다면 Collection 내부 각각들의 불변성(필요하다면 불변이 아니어도 됨)
  * 상태, 행위를 이곳에서 관리



* Car라는 클래스 객체 3개를 모두 관리해야할 때 Cars 쓰는것처럼

  * cars 하나의 인스턴스로 비즈니스로직 관리 가능



### Rest api

: API를 설계 할 때 자원을 나타내는 URI가 있고, http method를 통해 자원을 어떻게 처리할 지 설계하는 방식의 아키텍처

* 구성

  * 자원(resource) - URI / 행위 - HTTP method / 표현 representations




* 특징

  * URI로 지정된 리소스에 대한 조작을 한정적인 Interface를 통해 수행하는 아키텍처
  * Stateless
    * 작업을 위한 (client의)상태정보를 따로 저장 안함
    * 단순히 들어온 요청만을 처리 -> 불필요한 정보 관리 x
    * 만약 stateful하다면 서버가 클라이언트의 현재 상태를 저장해야한다. 따라서 클라이언트의 상태는 서버에 종속된다.
      * 이 경우의 로드밸런싱을 하는 경우에 서버가 클라이언트의 상태를 공유할수있는 redis같은 시스템이 필요.
    * Stateless하기 때문에 어느 서버가 처리하던 클라이언트의 요청은 동일하게 처리 가능.
  * client-server 구조: 서버는 API를 제공, 클라이언트는 세션이나 로그인 정보를 관리. 각각의 역할이 구분되고 의존성이 줄어들고 확장성은 높아진다.




* 장점

  * 원하는 타입으로 데이터를 주고받을 수 있다.
  * http method 타입과 uri만 읽어도 해당 인터페이스가 어떠한 기능과 연결되는지 파악이 용이하다
  * client-server구조. api로 들어오는 요청을 처리해 요청한대로 보내주기만 하면 된다. 각자의 역할이 명확히 분리 




* 단점

  * 복잡한 비즈니스에서 http method의 한계로 인해 모든 경우를 cover할 수 없을 것 같다.
  * 공식화 된 Rest API 표준이 존재하지 않다는 점도 아쉬운 점 중 하나.




### RPC (vs restapi)

* request parameter, reseponse parameter를 알아야한다.
  * 따라서 양쪽의 인터페이스 규약을 정의한 후, Skeleton, Stub 코드를 이용.	
* client, server간 연관관계가 돈독해진다(?), 즉 의존성 증가
* 계층간 함수명 등이 그대로 노출되는 구조라서 마이크로 서비스 내부 시스템, 디자인이 그대로 노출된다.



### TDD

test 주도형 개발. 기능 추가 전 테스트 먼저 작성.

*cf) given, when, then 기법*



* 장점:
  * 리팩토링에 용이. 크기가 커진 함수를 여러 함수로 나누는 과정에서 테스트 코드를 통해 계속 확인을 해가며 리팩토링을 해 중심을 잡을 수 있다.
  * 새로운 기능을 추가했을 때 해당 기능에 대한 테스트는 물론, 기존의 테스트들도 다 잘 돌아가는지 확인해 새로운 기능에 대해 신뢰를 할 수있다.



* 단점
  * 생산성이 줄어든다.
  * 모든 기능에 대해 100% 테스트코드를 작성할 수 없는 상황이 발생할 수 있다. 이 때 전략패턴과 같은 기법을 통해 개선할 수 있지만, 테스트를 위해 본 메서드를 변경하는 것 자체가 생산성을 저하시킨다.



### 디미터 법칙

* 객체가 자기 자신을 책임지는 자율적인 존재이다.
* 따라서 객체 내부 구조를 묻지 말고 무언가를 시켜라.



#### 디미터 법칙을 어긴 코드

``` kotlin
object.getChild().getContent().getItem().getTitle()
```

* 기차 충돌(train wreck) : 이와 같이 `getter` 가 줄줄이 이어진 코드
  * 이러한 설계는 객체들이 어떻게 연결되어있는지를 보여준다.
  * 객체 구조(연결)이 변경될 수 있으므로 프로그램은 불안정해진다.



#### 디미터 법칙이 하나의 .을 강제하는 규칙은 아니다.

```kotlin
IntStream.of(1, 15, 2)
  .filter(x -> x > 10)
  .distinct()
  .count();
```

* 이와 같은 코드가 기차 충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 것이다.
  * 하지만 `of`, `filter`, `distinct` 메서드는 모두 `IntStream` 이라는 동일한 클래스 인스턴스를 반환한다. 즉 이들은 `IntStream` 인스턴스를 또다른 `IntStream`인스턴스로 변환한다.
  * 따라서 이 코드는 디미터 법칙을 위반하지 않는다.



#### 디미터 법칙은 오직 결합도와 관련 된 것.

* 객체의 내부구조가 외부로 노출되는 경우에 해당됨.
* e. g) 이 관점에서 보면 racingCar 프로젝트에서 car의 위치들을 비교해 winner를 구하는 로직 또한 Cars가 아니라 Car에서 하는게 맞는 것.


