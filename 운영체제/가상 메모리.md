# 가상 메모리

: 프로세스에 필요한 메모리 전체가 물리 메모리에 적재되지 않고도 실행할 수 있도록 하는 기법

* 원래는 물리 메모리에 필요한 모든 것을 적재했었음
  * 실행할 프로그램에 필요한 메모리가 실제 물리 메모리보다 크다면 실행이 불가하다는 문제
* **논리 메모리와 물리 메모리 개념을 분리**
  * **가상 주소 공간**을 제공함으로써 개발자는 물리 메모리를 신경쓰지 않고 **가상 메모리만을 신경 쓰면 됨**



### 가상 주소 공간

* 한 프로세스가 메모리에 실제로 저장되는 논리적인 모습을 구현한 공간
* e.g) 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 할 때, 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구함.



### 프로세스 간 페이지 공유

* 각 물리 메모리 페이지들은 모든 프로세스에 공유되고 있음.
* `fork()`와 같은 것들로 프로세스를 생성하면 페이지들이 공유됨



## 요구 페이징(demand paging)

* 프로그램 전체를 디스크에서 메모리에 적재하지 않고 초기에 필요한 것만 적재
* 한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음.
* 프로세스 내 개별 페이지들은 페이저에 의해 관리됨.
* 만약 프로세스 중 물리메모리에 올라와있지 않은 페이지가 요구되면, **page fault**(페이지 부재)



## page fault

1. 디스크에서 필요한 페이지의 위치 찾음
2. 빈 페이지 프레임을 찾는다.
   1. **페이지 교체 알고리즘**을 통해 내려갈(swap out) 페이지를 고른다.
   2. 해당 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작



* *페이지 테이블과 요구 페이징*

<img src="https://media.vlpt.us/images/gimtommang11/post/2d82d84f-9878-4da4-b564-c78d9f47f838/demend_paging.png" alt="img" style="zoom: 67%;" /> 



### 페이지 교체 알고리즘

1. FIFO : 가장 오래된것 내리기

   * 이해하기 쉬우나, 오래된 페이지가 항상 필요하지 않다는 것을 보장할 수 없으며 효율이 좋지 않음
   * Beledy의 모순: 페이지를 저장할 수 있는 프레임 갯수를 늘려도 오히려 page fault가 많아지는 것

   

2. OPR(최적 페이지 교체): 앞으로 가장 오랫동안 사용되지 않을 페이지 내리기

   * 가장 효율이 좋으나, 구현이 일단 어려움
   * Beledy의 모순을 해결

   

3. LRU: 가장 오랫동안 참조(사용)되지 않은 페이지 내리기

   * FIFO보단 좋고, OPR보단 좋지 않다고 함.

   

4. LFU: 가장 적게 사용된 페이지 내리기

   * 특정 페이지가 초반에만 집중적으로 사용되었으면, 이제 더 이상 사용되지 않더라도 계속 메모리에 머물게 되는 문제.
   * 잘 쓰이지 않음



#### Reference)

#### https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS

#### https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

#### https://frontalnh.github.io/2018/04/04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/